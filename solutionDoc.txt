# What does success look like?

A

- bug free (understandable)
- implementation of a sublime syntax
- that can be autogenerated by tree notation

What's the problem?

This YAML/Regex language is challenging.

Why?

The whitespace/stack issue.

How do we solve it?

[] We need to understand all the tools available:

Does he allow multilines? No.

Even this: (?m ) seems to be ineffective.

[] We need to scan through other relevant languages looking for patterns to use

We've looked through Python and YAML so far.

What are the prime candidates for useful patterns?

( ) capture and \1 back references
push and pop
^(? ) looks aheads, look behinds, and negative look aheads and look behinds

We are going to have a hit, and need to remember the indent level of the last line.

[] Consider a hard coded solution

Three things:

- space increased? push context
- space same? process
- space decreased? pop context

Contexts can span multi-lines, but mathces are 1 line at a time, most


I wish we could capture a lookahead.
Let's see if we can.



[] Is it possible?

First line:
- enter context

Second line:
- pop context?
- proceed?

First line always pushes.
Should we always push?
And if we overpushed, pop?


[x] Can a capture group capture nothing?

- You can use an empty capture group: ()
- This also works: dog( ?)cat
 -- but does it do backref?






[] Can we outsource this?
[] Should I give up?




[] We cannot use backreferences in a lookbehind. Can we use them in a lookahead?




[ ] We need to know the YAML constructs used:


In yaml:
foo
 bar

Is same as:
foo
  bar

>- is line folding...Not part of regex.

foo: (dict)
 - (list)
 - match: (dict)
   bar:


[] How can we develop faster?

- We can make a color guide

7 colors:

contexts:
 main:
  #- include: canWeCaptureOptional
  - include: colors

 colors:
  - match: _blue
    scope: storage.type.string._blue
  - match: _red
    scope: entity.name.tag._red
  - match: _yellow
    scope: string.unquoted.plain.out._yellow
  - match: _gray_italics
    scope: comment.block.documentation._gray_italics # MATCH
  - match: _green
    scope: entity.name.function._green
  - match: _pink_back
    scope: invalid.illegal.error._pink_back # MATCH
  - match: _white
    scope: source._white
  - match: _orange
    scope: variable.parameter.function._orange
  - match: _purple
    scope: constant.numeric.yaml-version._purple







# http://www.sublimetext.com/docs/3/syntax.html
# http://www.sublimetext.com/docs/3/scope_naming.html
# https://manual.macromates.com/en/regular_expressions
# https://forum.sublimetext.com/t/indent-block-syntax-highlighting/24161/5
# https://forum.sublimetext.com/t/solved-syntax-tmlanguage-and-indentation/4276


# Key things is how to count the indent level. Use $1 or \1 ?



Facts:
- Can only read 1 line at a time
- Thus, each match has no access to line ahead of it or behind it
- However, it does have access to line before it in form of \1
- But it cannot lookahead across a line
- 


Learning Typescript:
[x] type guards, instance of guards
[] generics




Why am I building a tree language for this?
- Because I need to write grammars and parse them...



[] How do we break up the results?
  [] How does my return value handle line breaks?
  -- scopes can continue over lines (or can they??)
  [] Do we consume a character at a time?
[] Is it a global search or one?

You are only ever in 1 context at a time?
[] meta_scopes are used a lot to apply a context over a span.


We stay in a context until we pop off
In a context we apply a meta scope
We also apply 1 match in that context tops, to each section of text.


1. "abc".match(/./) // ["a", index: 0, input: "abc", groups: undefined]
2. "abc".match(/./g) // ["a", "b", "c"]

We don't match multiple matches for same part of text in a line.

Looks like we do 1 above. Run it on each line.
-- Do we go character by character?
-- How do we not apply 2 scopes?
-- Do we overwrite things?

:: When multiple patterns match at the same position, the first defined pattern will be selected.
--- note: a match might push things and so a later match might never get to match.

there's only going to be 1 match result?
No, we can have multiple. So how do we do it?
- with a //g?
- with character incrementing? no, b/c we have negative look behinds
- with removing matching strings? no, b/c of look behinds/aheads
- ANSWER: with re.exec!!!



Are results might be character wide.

Positions:

[0,1,2,3]


re = /bar/g
str = "foobarfoobar"
matches = []
while ((match = re.exec(str)) !== null) {
  matches.push(match)
}
["bar", index: 3, input: "foobarfoobar", groups: undefined]
["bar", index: 9, input: "foobarfoobar", groups: undefined]




runAllMatches


matchAll
then go through matches, top down, eliminating characters
- push or pop if you hit it



How are captures propagated along the stack?
-- This is proving very tricky to figure out.
-- This is one of the key problems.








# Look ahead (?= ) works but capture problem
# Capture works but advances the regex
# (?:) not captured group.?
# (?m) -> dot matches newline?
# From what I can tell ?m does not match newlines
#   - match: (?m:(F(.|\n)*))
#    scope: invalid.illegal.error.indentedBlock

  # (?=subexp)         look-ahead
  # (?!subexp)         negative look-ahead
  # (?<=subexp)        look-behind
  # (?<!subexp)        negative look-behind



5 simple things:
[] better interface/return value for "match"
NOTE: no need to pass state object? a single match cannot determine if it's a hit (because of leftmost rule)
[]
[]
[]
[]



[] Question: does his algo just do (match1|match2|match3)?





This latest bug.
- Is it a wrong required constructor thing? (i think so)
-- Yes. ContextNode is never being created. Why??


todo:
[] meta_scope
[] push/pop
[] 1. captures
[] backreferences
[] set
[] meta_content_scope
[] variables
[] include



Note: the current scope when you do ctrl+p is for the character after the cursor.
However, when there is no character on the line, you preserve the scope still.
-- This might be part of the problem with our thing. We may need to come back to this.





Note: it looks like there is a bug with "declaration" in typescript. It continues past where you'd expect.



Compile it to browser friendly make it real time for faster testing feedback?




When you push onto the stack, the new context DOES get the full line, but it seems that you only match from where the push happend. (You can do negative look behinds behind the current push)




name PHP
global_scope source.php
contexts
 main
  match \$[a-z]+
   scope f._red.php
  match <\?php
   scope foo._orange.php
  match <<<([A-Za-z][A-Za-z0-9_]*)
   push heredoc
  match \b\d+\b
   scope r._purple.int
 heredoc
  meta_scope f._blue.2
  match ^\1;
   pop true


Next steps:
- 10 test cases? For automated tests.
- we need automated tests. And that will get us through all things.


tap test.ts








name Flow
global_scope source.flow
contexts
 main
  match ( *)(go.table|chart)
   scope blue
   push tile content
  match .
   scope red
 tile
  match \1 left
   scope green
   push position
  match \1(?! )
   pop true
  match \1 .+
   scope pink
 position
  match \d+
   scope purple
  match .
   scope red
  match $
   pop true
 content
  match [a-z \d]
   scope orange
  match $
   pop true

x 32
 go.table
go.table hello man
 left 23 this should be error
 title foobar
chart bam
 chart
table h
 left 23
left 32


Do a real flow program:





Here's a problem:
- when you push a context midline, the new context has to look at whole line (for lookbehinds), BUT, that can break things like .+ (because they will be greedy and match the whole line, even though they should just match part you want to )..
-- So, do I handle lookbehinds manually??
-- do I special case lookbehinds?
-- do I drop support for lookbehinds?
-- Let's drop support for them for now, and see what happens.



[] Lookup javascript regex match offset.

[] Lookahead plus capture

^ matches immediately *after* a line break (does not capture break)
$ matches immediately *before* line break (does not capture break)

(?:x) non capturing.... same as (x), but doesnt remember match. helps when you want a group. that way you dont have to do weird offsets in your backreferences.


- A word boundary is not a "character" to be matched; like an anchor, a word boundary is not included in the match. In other words, the length of a matched word boundary is zero.

\w Equivalent to [A-Za-z0-9_]

\n Where n is a positive integer, a back reference to the last substring matching the n parenthetical in the regular expression (counting left parentheses). For example, /apple(,)\sorange\1/ matches 'apple, orange,' in "apple, orange, cherry, peach."

So you *can* have backreferences in the same REGEX!

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}




re.lastIndex = 6;



This works!!!

// Question: can we set lastIndex, to match from a line offset
    // while using the earlier part of the line for lookbehinds?
    // TEST:
    foo = new RegExp("(?<=za)bc", "g")
    foo.lastIndex = 1
    match1 = foo.exec("abc") // should not match
    foo.lastIndex = 1
    match2 = foo.exec("zabc") // should match











